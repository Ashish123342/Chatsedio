<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CallingApp — Single File (Advanced)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
  --primary: #666DC7;
  --primary-dark: #666DC7;
  --muted: linear-gradient(135deg, #eef2ff 0%, #f9fafb 100%);
  --card-bg: rgba(255,255,255,0.88);
  --card-blur: blur(8px);
  --danger: #ef4444;
  --success: #22c55e;
  --shadow: 0 10px 36px rgba(31, 38, 135, 0.09);
  --radius: 12px;
  --font: 'Inter', Arial, Helvetica, sans-serif;
}

body {
  margin: 0;
  min-height: 100vh;
  font-family: var(--font);
  background: var(--muted);
  color: #111827;
  letter-spacing: 0.01em;
  -webkit-font-smoothing: antialiased;
}

#app-container {
  max-width: 960px;
  margin: 40px auto 0 auto;
  display: flex;
  gap: 22px;
  padding: 14px;
}

.panel {
  background: var(--card-bg);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 26px 22px;
  flex: 1;
  min-height: 640px;
  backdrop-filter: var(--card-blur);
  border: 1px solid #e5e7eb;
  transition: box-shadow 0.3s ease, transform 0.15s ease;
  overflow: visible;
}
.panel:hover {
  box-shadow: 0 12px 40px rgba(37, 99, 235, 0.08);
  transform: translateY(-2px);
}

header.app-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 22px;
  position: relative;
  z-index: 60;
}

h3 {
  font-size: 16px;
  letter-spacing: .04em;
  margin: 0;
  color: var(--primary-dark);
  font-weight: 800;
  text-shadow: 0 2px 16px #c7d2fe55;
}

button {
  padding: 11px 24px;
  border-radius: 14px;
  border: 0;
  min-width: 80px;
  background: linear-gradient(90deg, var(--primary) 0%, var(--primary-dark) 100%);
  color: #fff;
  font-weight: 700;
  font-family: var(--font);
  font-size: 10px;
  cursor: pointer;
  box-shadow: 0 4px 14px rgba(59, 130, 246, 0.25);
  transition: all 0.15s ease-in-out;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  transform: translateZ(0);
  will-change: transform, box-shadow;
}
button:hover, button:active {
  background: linear-gradient(100deg, var(--primary-dark) 20%, #4338ca 100%);
  transform: translateY(-2px) scale(1.05);
}
button:not([disabled]):hover {
  box-shadow:
    0 3px 20px rgba(99, 102, 241, 0.22),
    0 2px 10px rgba(37, 99, 235, 0.18);
}

input, select, textarea {
  width: 100%;
  padding: 13px 11px;
  margin: 12px 0 20px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  background: #f9fafb;
  transition: all 0.2s;
  font-size: 15px;
  font-family: var(--font);
}
input:focus, select:focus, textarea:focus {
  border-color: var(--primary);
  background: #fff;
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.18);
  outline: none;
}

.hidden { display: none !important; }

.row, .flex { display: flex; gap: 12px; align-items: center; }
.flex-col { display: flex; flex-direction: column; }

/* ===== CONTACT CARDS ===== */
.contact {
  position: relative;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
  padding: 14px;
  margin-bottom: 12px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  background: rgba(248, 250, 255, 0.92);
  box-shadow: 0 1px 8px rgba(147, 197, 253, 0.12);
  transition: box-shadow 0.18s, border 0.2s, transform 0.12s;
  overflow: visible;
}
.contact:hover {
  border: 1.7px solid #6366f1;
  box-shadow: 0 4px 14px rgba(99, 102, 241, 0.18);
  transform: translateY(-2px);
}

.contact .meta {
  flex: 1 1 auto;
  min-width: 0;
}

.contact .actions {
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: flex-end;
  flex-shrink: 0;
  margin-left: 12px;
}

.contact .actions button {
  border-radius: 12px;
  padding: 10px 18px;
  min-width: 88px;
  white-space: nowrap;
  box-shadow: 0 6px 18px rgba(37,99,235,0.12);
}

/* UID / long text handling */
.uid, .contact .uid-text {
  display: block;
  word-break: break-word;
  overflow-wrap: anywhere;
  hyphens: auto;
  color: #6b7280;
}
.uid.clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.badge {
  background: var(--danger);
  color: #fff;
  padding: 4px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.01em;
  margin-left: 8px;
  vertical-align: middle;
  box-shadow: 0 1px 5px rgba(239, 68, 68, 0.35);
}

/* ===== CHAT AREA ===== */
.chat-area {
  border: 1px solid #e5e7ef;
  border-radius: 14px;
  padding: 14px;
  max-height: 430px;
  overflow: auto;
  background: #f3f6fc;
  margin-bottom: 12px;
}

.message {
  margin: 8px 0;
  padding: 13px 18px;
  border-radius: 15px;
  max-width: 78%;
  font-size: 16px;
  line-height: 1.5;
  box-shadow: 0 1px 7px rgba(96, 165, 250, 0.12);
  transition: background 0.15s, transform 0.1s;
}
.me {
  background: linear-gradient(90deg, #33C0FF, #33C0FF);
  align-self: flex-end;
  color: #fff;
  font-weight: bold;
  font-size:15px;
}
.them {
  background: #fff;
  align-self: flex-start;
  font-weight :bold;
 font-size: 15px;
}

footer, .small {
  margin-top: 16px;
  font-size: 13px;
  color: #6b7280;
}

.call-local, .call-remote {
  width: 180px;
  height: 135px;
  background: #000;
  border-radius: 14px;
  overflow: hidden;
  box-shadow: 0 2px 16px rgba(219, 234, 254, 0.55);
  border: 2.4px solid #c7d2fe;
}

.danger {
  background: #fff5f5;
  border: 1.2px solid #fecaca;
  color: var(--danger);
  padding: 11px;
  border-radius: 12px;
  font-weight: 600;
}

::-webkit-scrollbar { width: 8px; background: #e5e7ef; }
::-webkit-scrollbar-thumb { background: #a5b4fc; border-radius: 7px; }

#main-left > div.flex > strong {
  font-size: 19px;
  font-weight: 700;
  letter-spacing: 0.03em;
}

#profile-card {
  background: #fafafea6;
  box-shadow: 0 2px 10px rgba(129, 140, 248, 0.15);
  border-radius: 14px;
  border: 1.5px solid rgba(165, 180, 252, 0.4);
  padding: 16px;
  font-size: 15px;
}

#profile-emoji {
  font-size: 30px;
  vertical-align: middle;
}

hr {
  border: none;
  border-top: 1.6px solid #e0e7ef;
  margin: 22px 0;
  opacity: 0.75;
}

input[type="password"] {
  letter-spacing: 0.15em;
}

/* ===== Responsive & fallbacks ===== */
@media (max-width: 820px) {
  #app-container { flex-direction: column; max-width: 99vw; gap: 14px; }
  .panel { min-height: 440px; padding: 16px 7vw; }
  .contact .actions { flex-direction: row; gap: 8px; }
}

@media (prefers-reduced-motion: reduce) {
  * { transition: none !important; }
}

/* fallback if backdrop-filter unsupported */
@supports not ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))) {
  .panel { background: rgba(255,255,255,0.97); --card-blur: none; }
}
</style>
</head>
<body>
  <div id="app-container">
    <!-- LEFT: Auth / Profile / Contacts -->
    <div class="panel" style="flex:0.9; min-width:320px;">
      <header class="app-header">
        <h3>Tsedio</h3>
        <div id="auth-controls">
          <span id="user-display" class="small"></span>
          <button id="btn-logout" class="hidden" onclick="logout()">Logout</button>
        </div>
      </header>

      <!-- AUTH -->
      <div id="auth-view">
        <h3>Login</h3>
        <input type="email" id="login-email" placeholder="Email">
        <input id="login-pass" type="password" placeholder="Password">
        <div class="row">
          <button onclick="login()">Login</button>
          <button onclick="showSignup()">Signup</button>
        </div>
        <div id="auth-error" class="small" style="color:#c00"></div>
      </div>

      <!-- SIGNUP -->
      <div id="signup-view" class="hidden">
        <h3>Create account</h3>
        <input id="signup-email" placeholder="Email">
        <input id="signup-pass" type="password" placeholder="Password">
        <div class="row">
          <button onclick="signup()">Create</button>
          <button onclick="showLogin()">Back</button>
        </div>
        <div id="signup-error" class="small" style="color:#c00"></div>
      </div>

      <!-- PROFILE SETUP -->
      <div id="profile-setup" class="hidden">
        <h3>Setup Profile</h3>
        <div class="small">Choose a display name (this will be your public username) — emoji will be generated.</div>
        <input id="profile-name" placeholder="Display name (like Ashish)">
        <div class="row">
          <button onclick="saveProfile()">Save Profile</button>
        </div>
        <div id="profile-error" class="small" style="color:#c00"></div>
      </div>

      <!-- CONTACTS & REQUESTS -->
      <div id="main-left" class="hidden">
        <div class="flex" style="justify-content:space-between">
          <strong>Contacts</strong>
          <div>
            <button onclick="openFind()">Add Friend</button>
            <button onclick="openRequests()">Requests</button>
          </div>
        </div>

        <div id="contacts-list" style="margin-top:12px;"></div>

        <hr>

        <div class="flex" style="justify-content:space-between; align-items:center;">
          <strong>My Profile</strong>
          <button onclick="openProfile()">Edit</button>
        </div>

        <div id="profile-card" style="margin-top:8px; padding:8px; border-radius:8px; border:1px solid #eee;">
          <div><span id="profile-emoji" style="font-size:22px"></span> <strong id="profile-display"></strong></div>
          <div class="small" id="profile-uid"></div>
          <div class="small">Blocked: <span id="blocked-count">0</span></div>
          <div style="margin-top:8px;"><button onclick="copyUID()">Copy UID</button></div>
        </div>
      </div>

      <!-- FIND FRIEND / SEND REQUEST -->
      <div id="find-view" class="hidden">
        <h3>Add friend by UID</h3>
        <div class="small">Enter recipient UID (from their profile)</div>
        <input id="find-uid" placeholder="Paste UID">
        <button onclick="sendFriendRequest()">Send Request</button>
        <div id="find-msg" class="small"></div>
      </div>

      <!-- REQUESTS -->
      <div id="requests-view" class="hidden">
        <h3>Incoming Requests</h3>
        <div id="requests-list"></div>
      </div>
    </div>

    <!-- RIGHT: Chat / Calls -->
    <div class="panel" style="flex:1.6;">
      <!-- Chat header -->
      <div id="chat-controls" class="hidden">
        <div class="flex" style="justify-content:space-between;">
          <div>
            <strong id="chat-with">Select contact</strong><div class="small" id="chat-with-uid"></div>
          </div>
          <div>
            <button onclick="startCall()">Call</button>
            <button onclick="blockUser()" id="btn-block">Block</button>
            <button onclick="unblockUser()" id="btn-unblock" class="hidden">Unblock</button>
          </div>
        </div>
      </div>

      <div id="chat-area" class="hidden">
        <div class="chat-area flex-col" id="messages"></div>

        <div style="margin-top:12px;" class="row">
          <input id="message-input" placeholder="Type message...">
          <button onclick="sendChatMessage()">Send</button>
        </div>
        <div class="small" id="unread-info"></div>
      </div>

      <!-- Calls UI -->
      <div id="webrtc-ui" class="hidden" style="margin-top:12px;">
        <div class="flex" style="gap:12px;">
          <div>
            <div class="small">Local</div>
            <video id="localVideo" autoplay muted playsinline class="call-local"></video>
          </div>
          <div>
            <div class="small">Remote</div>
            <video id="remoteVideo" autoplay playsinline class="call-remote"></video>
          </div>
        </div>
        <div style="margin-top:10px;">
          <button id="end-call-btn" onclick="endCall()" class="danger">End Call</button>
        </div>
      </div>

      <!-- Incoming call modal -->
      <div id="incoming-call" class="hidden" style="margin-top:12px; padding:12px; border-radius:8px; border:1px solid #eee;">
        <div class="flex" style="justify-content:space-between;">
          <div>
            <strong id="incoming-from"></strong>
            <div class="small" id="incoming-uid"></div>
          </div>
          <div>
            <button onclick="acceptIncoming()">Accept</button>
            <button onclick="rejectIncoming()" class="danger">Reject</button>
          </div>
        </div>
      </div>

      <div id="system-log" style="margin-top:12px;" class="small"></div>
    </div>
  </div>

  <!-- Firebase + App JS -->
  <script type="module">
    // ---------------------------
    // Firebase Imports (modular)
    // ---------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import {
      getDatabase, ref, set, push, onChildAdded, onValue, remove, update, get, child
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    // ---------------------------
    // CONFIG - Replace with your keys
    // ---------------------------
    const firebaseConfig = {
  apiKey: "AIzaSyDTjjxt12p-0CMeey4EjKqiWAz9trGB0kQ",
  authDomain: "tsedio-a122c.firebaseapp.com",
  databaseURL: "https://tsedio-a122c-default-rtdb.firebaseio.com",
  projectId: "tsedio-a122c",
  storageBucket: "tsedio-a122c.firebasestorage.app",
  messagingSenderId: "44533653921",
  appId: "1:44533653921:web:07676dce93af9690136be0",
  measurementId: "G-ZFZG6MBV1X"
};

    const app = initializeApp(firebaseConfig);
    const auth = getAuth();
    const db = getDatabase(app);

    // ---------------------------
    // Globals
    // ---------------------------
    let currentUser = null;
    let myProfile = null;
    let activeChatUid = null; // UID of currently selected contact
    let listeners = []; // cleanup refs
    let localStream = null;
    let pc = null;
    let callDocRef = null;
    let currentCallId = null;
    const configuration = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    // ---------------------------
    // UI Helpers
    // ---------------------------
    const $ = id => document.getElementById(id);
    function log(msg){ const el=$('system-log'); el.innerText = (new Date()).toLocaleTimeString() + " — " + msg + "\n" + el.innerText; }

    // ---------------------------
    // AUTH
    // ---------------------------
    window.showSignup = ()=> { $('auth-view').classList.add('hidden'); $('signup-view').classList.remove('hidden'); }
    window.showLogin  = ()=> { $('signup-view').classList.add('hidden'); $('auth-view').classList.remove('hidden'); }

    window.signup = async ()=>{
      const email = $('signup-email').value.trim();
      const pass = $('signup-pass').value.trim();
      $('signup-error').innerText = "";
      if (!email || !pass){ $('signup-error').innerText="Enter email & password"; return; }
      try{
        await createUserWithEmailAndPassword(auth, email, pass);
      }catch(e){ $('signup-error').innerText = e.message; }
    };

    window.login = async ()=>{
      const email = $('login-email').value.trim();
      const pass = $('login-pass').value.trim();
      $('auth-error').innerText = "";
      try{
        await signInWithEmailAndPassword(auth, email, pass);
      }catch(e){ $('auth-error').innerText = e.message; }
    };

    window.logout = async ()=>{
      await signOut(auth);
      location.reload();
    };

    // Auth state listener
    onAuthStateChanged(auth, async user=>{
      if (user){
        currentUser = user;
        $('user-display').innerText = user.email;
        $('btn-logout').classList.remove('hidden');
        $('auth-view').classList.add('hidden');
        $('signup-view').classList.add('hidden');

        // check profile
        const profSnap = await get(child(ref(db), `profiles/${user.uid}`));
        if (!profSnap.exists()){
          // show profile setup
          $('profile-setup').classList.remove('hidden');
        } else {
          myProfile = profSnap.val();
          initMainUI();
        }
      } else {
        currentUser = null;
        myProfile = null;
        $('user-display').innerText = "";
        $('btn-logout').classList.add('hidden');
        $('auth-view').classList.remove('hidden');
        $('main-left').classList.add('hidden');
        $('chat-controls').classList.add('hidden');
        $('chat-area').classList.add('hidden');
      }
    });

    // ---------------------------
    // PROFILE
    // ---------------------------
    const EMOJIS = ["😄","😎","🤖","🔥","🌟","🎯","💡","🧠","🚀","🎵","🍀","🌈","🐾","🌻","⚡"];
    function genEmoji(name){
      if(!name) return EMOJIS[Math.floor(Math.random()*EMOJIS.length)];
      // stable pick by char codes
      let s=0; for(let ch of name){ s+=ch.charCodeAt(0); } return EMOJIS[s % EMOJIS.length];
    }

    window.saveProfile = async ()=>{
      const name = $('profile-name').value.trim();
      if (!name) { $('profile-error').innerText = "Enter a display name"; return; }
      $('profile-error').innerText = "";
      const profile = { displayName: name, emoji: genEmoji(name), createdAt: Date.now(), blocked: {} };
      await set(ref(db, `profiles/${currentUser.uid}`), profile);
      myProfile = profile;
      initMainUI();
    };

    function openProfile(){
      $('profile-setup').classList.remove('hidden');
      $('profile-name').value = myProfile.displayName || "";
    }

    function copyUID(){
      navigator.clipboard?.writeText(currentUser.uid);
      alert("UID copied: " + currentUser.uid);
    }

    // ---------------------------
    // MAIN UI INIT
    // ---------------------------
    function initMainUI(){
      $('profile-setup').classList.add('hidden');
      $('auth-view').classList.add('hidden');
      $('signup-view').classList.add('hidden');
      $('main-left').classList.remove('hidden');
      $('chat-controls').classList.remove('hidden');
      $('chat-area').classList.add('hidden'); // show when contact selected
      updateProfileCard();
      attachContactsListener();
      attachRequestsListener();
      attachIncomingCallListener();
      log("Initialized main UI");
    }

    function updateProfileCard(){
      $('profile-emoji').innerText = myProfile.emoji || "🙂";
      $('profile-display').innerText = myProfile.displayName || currentUser.email;
      $('profile-uid').innerText = "UID: " + currentUser.uid;
      $('blocked-count').innerText = Object.keys(myProfile.blocked || {}).length;
    }

    // ---------------------------
    // FRIEND REQUESTS & CONTACTS
    // ---------------------------
    function attachRequestsListener(){
      const reqRef = ref(db, `requests/${currentUser.uid}`);
      // Warm clear UI
      $('requests-list').innerHTML = "";
      // on each incoming request push by others to requests/{recipientUid}/{pushId}
      onChildAdded(reqRef, snap=>{
        const data = snap.val();
        const pushId = snap.key;
        const el = document.createElement('div');
        el.className = 'contact';
        el.innerHTML = `<div><strong>${data.fromName || data.fromEmail}</strong><div class="small">${data.fromUid}</div></div>
                        <div class="row">
                          <button onclick="acceptRequest('${pushId}','${data.fromUid}','${data.fromName || data.fromEmail}')">Accept</button>
                          <button onclick="rejectRequest('${pushId}')">Reject</button>
                        </div>`;
        $('requests-list').appendChild(el);
      });
    }

    window.openRequests = ()=> {
      $('requests-view').classList.toggle('hidden');
      $('find-view').classList.add('hidden');
    }

    window.openFind = ()=> {
      $('find-view').classList.toggle('hidden');
      $('requests-view').classList.add('hidden');
      $('find-msg').innerText="";
    }

    window.sendFriendRequest = async ()=>{
      const targetUid = $('find-uid').value.trim();
      if (!targetUid){ $('find-msg').innerText="Enter UID"; return; }
      if (targetUid === currentUser.uid){ $('find-msg').innerText="You can't add yourself."; return; }
      // create request at requests/{recipientUid}/{pushId}
      const payload = { fromUid: currentUser.uid, fromEmail: currentUser.email, fromName: myProfile.displayName || currentUser.email, timestamp: Date.now() };
      await push(ref(db, `requests/${targetUid}`), payload);
      $('find-msg').innerText = "Request sent.";
    };

    window.acceptRequest = async (pushId, fromUid, fromName) => {
      // Add to both users' contacts
      await set(ref(db, `contacts/${currentUser.uid}/${fromUid}`), { uid: fromUid, name: fromName, since: Date.now() });
      await set(ref(db, `contacts/${fromUid}/${currentUser.uid}`), { uid: currentUser.uid, name: myProfile.displayName || currentUser.email, since: Date.now() });
      // remove request
      await remove(ref(db, `requests/${currentUser.uid}/${pushId}`));
      log("Accepted friend: " + fromUid);
      // refresh contacts list will show it automatically
    };

    window.rejectRequest = async (pushId) => {
      await remove(ref(db, `requests/${currentUser.uid}/${pushId}`));
      log("Rejected request");
    };

    function attachContactsListener(){
      const cRef = ref(db, `contacts/${currentUser.uid}`);
      const container = $('contacts-list');
      container.innerHTML = "<div class='small'>Loading contacts...</div>";
      onValue(cRef, snap=>{
        container.innerHTML = "";
        if (!snap.exists()){ container.innerHTML = "<div class='small'>No contacts</div>"; return; }
        snap.forEach(childSnap=>{
          const c = childSnap.val();
          const uid = childSnap.key;
          // skip if blocked
          if (myProfile.blocked && myProfile.blocked[uid]) return;
          const el = document.createElement('div');
          el.className = 'contact';
          el.innerHTML = `<div>
                            <div style="font-weight:600;">${c.name || uid} <span class="small">(${uid===currentUser.uid?'me':''})</span></div>
                            <div class="small">${new Date(c.since).toLocaleDateString()}</div>
                          </div>
                          <div style="display:flex; flex-direction:column; gap:6px;">
                            <button onclick="openChat('${uid}','${(c.name||'')}')">Chat</button>
                            <button onclick="startCall('${uid}')" style="background:#10b981">Call</button>
                          </div>`;
          container.appendChild(el);
        });
      });
    }

    // ---------------------------
    // CHAT: per chat-room and unread counts
    // chatId = sorted combination of two UIDs (smallest_first + '_' + largest)
    // ---------------------------
    function chatIdFor(a,b){
      return (a<b) ? `${a}_${b}` : `${b}_${a}`;
    }

    window.openChat = async (uid, name) => {
      activeChatUid = uid;
      $('chat-controls').classList.remove('hidden');
      $('chat-area').classList.remove('hidden');
      $('chat-with').innerText = name || uid;
      $('chat-with-uid').innerText = uid;
      $('messages').innerHTML = "";
      $('unread-info').innerText = "";
      $('incoming-call').classList.add('hidden');

      // check block status
      const blocked = myProfile.blocked || {};
      if (blocked[uid]) {
        $('btn-block').classList.add('hidden');
        $('btn-unblock').classList.remove('hidden');
        $('message-input').disabled = true;
      } else {
        $('btn-block').classList.remove('hidden');
        $('btn-unblock').classList.add('hidden');
        $('message-input').disabled = false;
      }

      // attach messages listener
      const id = chatIdFor(currentUser.uid, uid);
      const msgsRef = ref(db, `messages/${id}`);
      onValue(msgsRef, snap=>{
        $('messages').innerHTML = "";
        if (!snap.exists()) return;
        snap.forEach(child=>{
          const m = child.val();
          const div = document.createElement('div');
          div.className = 'message ' + ((m.senderUid===currentUser.uid) ? 'me' : 'them');
          div.innerText = ` ${m.text}`;
          $('messages').appendChild(div);
        });
        // scroll
        $('messages').scrollTop = $('messages').scrollHeight;
      });

      // mark unread = 0 for me
      const myUnreadRef = ref(db, `unread/${id}/${currentUser.uid}`);
      set(myUnreadRef, 0);
    };

    window.sendChatMessage = async ()=>{
      if (!activeChatUid) { alert("Select a contact"); return; }
      const text = $('message-input').value.trim();
      if (!text) return;
      // check block
      if (myProfile.blocked && myProfile.blocked[activeChatUid]) { alert("Unblock to send"); return; }

      const id = chatIdFor(currentUser.uid, activeChatUid);
      const payload = { text, senderUid: currentUser.uid, senderEmail: currentUser.email, senderName: myProfile.displayName || currentUser.email, ts: Date.now() };
      await push(ref(db, `messages/${id}`), payload);
      // increment unread for recipient
      const otherUnreadRef = ref(db, `unread/${id}/${activeChatUid}`);
      // read current unread, increment simple way: set to (existing+1)
      const snap = await get(otherUnreadRef);
      const val = snap.exists() ? (snap.val() || 0) : 0;
      set(otherUnreadRef, val + 1);
      $('message-input').value = "";
    };

    // show unread badges at contacts list
    const attachUnreadListener = () => {
      const myContactsRef = ref(db, `contacts/${currentUser.uid}`);
      onValue(myContactsRef, snap=>{
        // iterate contacts and check unread for each chat
        const container = $('contacts-list');
        // already updated via contacts listener; we will append badges after small delay
        setTimeout(async ()=>{
          const nodes = container.querySelectorAll('.contact');
          // quick approach: fetch unread keys under unread for each possible chat id where other is contact
          snap.forEach(async cSnap => {
            const otherUid = cSnap.key;
            const id = chatIdFor(currentUser.uid, otherUid);
            const unreadSnap = await get(ref(db, `unread/${id}/${currentUser.uid}`));
            const n = unreadSnap.exists() ? (unreadSnap.val() || 0) : 0;
            // find the contact element for this uid and show badge
            nodes.forEach(node=>{
              if (node.innerText.includes(otherUid) || node.innerText.includes(cSnap.val().name)){
                let bad = node.querySelector('.badge');
                if (!bad && n>0){
                  bad = document.createElement('span'); bad.className='badge'; bad.innerText = n;
                  node.querySelector('div').appendChild(bad);
                } else if (bad){
                  if (n>0) bad.innerText = n; else bad.remove();
                }
              }
            });
          });
        }, 200);
      });
    };

    // run unread listener when main UI ready
    // call within initMainUI
    // I'll call it after attachContactsListener finishes updating
    // So modify attachContactsListener to call attachUnreadListener at end
    // For simplicity call it here with a small timeout (after auth)
    setInterval(()=>{ if (currentUser) attachUnreadListener(); }, 5000);

    // ---------------------------
    // BLOCK / UNBLOCK
    // ---------------------------
    window.blockUser = async ()=>{
      if (!activeChatUid) return;
      myProfile.blocked = myProfile.blocked || {};
      myProfile.blocked[activeChatUid] = Date.now();
      await update(ref(db, `profiles/${currentUser.uid}`), { blocked: myProfile.blocked });
      updateProfileCard();
      $('btn-block').classList.add('hidden');
      $('btn-unblock').classList.remove('hidden');
      $('message-input').disabled = true;
      log("Blocked " + activeChatUid);
    };

    window.unblockUser = async ()=>{
      if (!activeChatUid) return;
      myProfile.blocked = myProfile.blocked || {};
      delete myProfile.blocked[activeChatUid];
      await update(ref(db, `profiles/${currentUser.uid}`), { blocked: myProfile.blocked });
      updateProfileCard();
      $('btn-block').classList.remove('hidden');
      $('btn-unblock').classList.add('hidden');
      $('message-input').disabled = false;
      log("Unblocked " + activeChatUid);
    };

    // ---------------------------
    // WEBRTC CALLING (Signaling via Realtime DB)
    // - startCall(targetUid)  -> creates call doc at calls/{callId}
    // - acceptIncoming -> reads offer, create answer, set to DB
    // - exchange ICE candidates under calls/{callId}/callerCandidates and .../calleeCandidates
    // ---------------------------

    function attachIncomingCallListener(){
      // Listen to calls node to see new entries directed to current user
      const callsRef = ref(db, `calls`);
      onChildAdded(callsRef, async snap=>{
        const c = snap.val();
        const id = snap.key;
        // if this call is for me and it's in "offer" state and I'm the callee:
        if (c.calleeUid === currentUser.uid && c.status === 'offer'){
          // show incoming UI
          $('incoming-from').innerText = c.callerName || c.callerUid;
          $('incoming-uid').innerText = c.callerUid;
          $('incoming-call').classList.remove('hidden');
          // store currentCallId for accept/reject
          currentCallId = id;
          log("Incoming call from " + c.callerUid);
        }
      });
    }

    window.startCall = async (targetUid) => {
      // if targetUid passed (from contacts), use it; else if activeChatUid selected use it
      if (!targetUid) targetUid = activeChatUid;
      if (!targetUid) { alert("Select contact to call"); return; }

      // don't call if blocked
      if (myProfile.blocked && myProfile.blocked[targetUid]) { alert("Cannot call blocked user"); return; }

      // prepare call doc
      const callRef = push(ref(db, 'calls'));
      const callId = callRef.key;
      currentCallId = callId;

      // init local stream and pc
      localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:true }).catch(e=>{ alert("Microphone/Camera permission needed"); throw e; });
      $('localVideo').srcObject = localStream;
      $('webrtc-ui').classList.remove('hidden');

      pc = new RTCPeerConnection(configuration);
      // add tracks
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      // when remote track arrives
      pc.ontrack = event => {
        $('remoteVideo').srcObject = event.streams[0];
      };
      // ICE candidates => write to DB under callerCandidates
      const callerCandidatesRef = ref(db, `calls/${callId}/callerCandidates`);
      pc.onicecandidate = event => {
        if (event.candidate){
          push(callerCandidatesRef, event.candidate.toJSON());
        }
      };

      // create offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // create call entry
      await set(callRef, {
        callerUid: currentUser.uid,
        callerName: myProfile.displayName || currentUser.email,
        calleeUid: targetUid,
        status: 'offer',
        sdp: offer.sdp,
        createdAt: Date.now()
      });

      log("Call offer sent to " + targetUid);

      // listen for answer and remote ICE
      const callSnapRef = ref(db, `calls/${callId}`);
      onValue(callSnapRef, async snap=>{
        const val = snap.val();
        if (!val) return;
        // if answer arrives
        if (val.status === 'answered' && val.answerSdp){
          const remoteDesc = { type: 'answer', sdp: val.answerSdp };
          await pc.setRemoteDescription(remoteDesc);
          log("Remote description set (answer)");
        }
      });

      // listen for callee ICE candidates
      const calleeCandidatesRef = ref(db, `calls/${callId}/calleeCandidates`);
      onChildAdded(calleeCandidatesRef, snap=>{
        const cand = snap.val();
        if (cand) pc.addIceCandidate(cand).catch(e=>console.warn(e));
      });
    };

    window.acceptIncoming = async ()=>{
      if (!currentCallId) return;
      $('incoming-call').classList.add('hidden');

      const callRef = ref(db, `calls/${currentCallId}`);
      const callSnap = await get(callRef);
      if (!callSnap.exists()) { log("Call no longer exists"); return; }
      const callData = callSnap.val();

      // create local stream & pc
      localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:true }).catch(e=>{ alert("Allow camera/mic"); throw e; });
      $('localVideo').srcObject = localStream;
      $('webrtc-ui').classList.remove('hidden');

      pc = new RTCPeerConnection(configuration);
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      pc.ontrack = event => { $('remoteVideo').srcObject = event.streams[0]; };

      // ICE: calleeCandidates -> write
      const calleeCandidatesRef = ref(db, `calls/${currentCallId}/calleeCandidates`);
      pc.onicecandidate = event => {
        if (event.candidate) push(calleeCandidatesRef, event.candidate.toJSON());
      };

      // set remote desc from offer
      const offerDesc = { type:'offer', sdp: callData.sdp };
      await pc.setRemoteDescription(offerDesc);

      // create answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // update call doc with answer
      await update(callRef, { answerSdp: answer.sdp, status: 'answered' });

      // listen for caller ICE
      const callerCandidatesRef = ref(db, `calls/${currentCallId}/callerCandidates`);
      onChildAdded(callerCandidatesRef, snap=>{
        const cand = snap.val();
        if (cand) pc.addIceCandidate(cand).catch(e=>console.warn(e));
      });

      log("Answered call " + currentCallId);
    };

    window.rejectIncoming = async ()=>{
      if (!currentCallId) return;
      await update(ref(db, `calls/${currentCallId}`), { status: 'rejected' });
      $('incoming-call').classList.add('hidden');
      log("Call rejected");
      currentCallId = null;
    };

    window.endCall = async ()=>{
      if (!currentCallId) return;
      await update(ref(db, `calls/${currentCallId}`), { status: 'ended' });
      cleanupCall();
      log("Call ended");
    };

    async function cleanupCall(){
      try{
        if (pc){ pc.close(); pc = null; }
        if (localStream){ localStream.getTracks().forEach(t=>t.stop()); localStream = null; }
        $('webrtc-ui').classList.add('hidden');
        $('localVideo').srcObject = null;
        $('remoteVideo').srcObject = null;
        currentCallId = null;
      } catch(e){ console.warn(e); }
    }

    // Also listen for changes to call status to cleanup on remote hangup/reject
    const monitorCallsForCleanup = () => {
      const callsRef = ref(db, 'calls');
      onChildAdded(callsRef, snap=>{
        const id = snap.key;
        onValue(ref(db, `calls/${id}/status`), snap2=>{
          const s = snap2.val();
          if (s === 'ended' || s === 'rejected'){
            if (currentCallId === id){
              cleanupCall();
              log("Remote ended/rejected call");
            }
          }
        });
      });
    };
    monitorCallsForCleanup();

    // ---------------------------
    // Incoming call accept via button, and more
    // ---------------------------
    window.rejectCall = window.rejectIncoming; // alias

    // ---------------------------
    // Misc utilities
    // ---------------------------
    function uidShort(u){ return u ? u.substr(0,6) : ''; }
    // small heartbeat to refresh profile from DB (so blocked changes reflect quickly)
    setInterval(async ()=>{
      if (!currentUser) return;
      const snap = await get(ref(db, `profiles/${currentUser.uid}`));
      if (snap.exists()){
        myProfile = snap.val();
        updateProfileCard();
      }
    }, 5000);

    // ---------------------------
    // Initial small instructions in console and system-log
    // ---------------------------
    log("App loaded. Please sign up / login. Replace firebaseConfig with your keys.");

    // END of MODULE
  </script>
</body>
</html>